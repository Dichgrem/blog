<!DOCTYPE html>
<html lang="en">

<head>
    <title>Dich&#x27;blog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://blog.dich.ink/style.css">
    <link rel="stylesheet" href="https://blog.dich.ink/color/blue.css">

        <link rel="stylesheet" href="https://blog.dich.ink/color/background_dark.css">
    
    <link rel="stylesheet" href="https://blog.dich.ink/font-hack-subset.css">

    <meta name="description" content="">

    <meta property="og:description" content="">
    <meta property="og:title" content="Dich'blog">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://blog.dich.ink/docker-learn-9/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="">
    <meta name="twitter:title" content="Dich'blog">
    <meta property="twitter:domain" content="blog.dich.ink">
    <meta property="twitter:url" content="https://blog.dich.ink/docker-learn-9/">

        <link rel="alternate" type="application/atom+xml" title="Dich&#x27;blog Atom Feed" href="https://blog.dich.ink/atom.xml" />
    
    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://blog.dich.ink" style="text-decoration: none;">
                    <div class="logo">
                      
                            Dich&#x27;blog
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://blog.dich.ink">blog</a></li>
            
                <li><a href="https://blog.dich.ink/tags">tags</a></li>
            
                <li><a href="https://blog.dich.ink/archive">archive</a></li>
            
                <li><a href="https://blog.dich.ink/about">about me</a></li>
            
                <li><a href="https://blog.dich.ink/links">links</a></li>
            
                <li><a href="https://blog.dich.ink/search">search</a></li>
            
                <li><a href="https://github.com/Dichgrem" target="_blank" rel="noopener noreferrer">github</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://blog.dich.ink/docker-learn-9/">Docker学习笔记(九)</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2024-04-02
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://blog.dich.ink/tags/xue-xi-bi-ji/">#学习笔记</a></span>
    

        <div class="post-content">
            <p>前言 Docker CLI（命令行界面）是一个强大的工具，允许您与 Docker 容器、映像、卷和网络进行交互和管理。它为用户提供了广泛的命令，用于在开发和生产工作流中创建、运行和管理 Docker 容器和其他 Docker 资源。</p>
<span id="continue-reading"></span>
<p>在本主题中，我们将深入探讨 Docker CLI 的一些关键方面，包括以下内容：</p>
<p><strong>1. 安装</strong></p>
<p>要开始使用 Docker CLI，您需要在计算机上安装 Docker。您可以按照 Docker 文档中相应操作系统的官方安装指南进行操作。</p>
<p><strong>2. 基本命令</strong></p>
<p>以下是一些需要熟悉的基本 Docker CLI 命令：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>docker run：从 Docker 镜像创建并启动容器
</span><span>docker container：列出正在运行的容器
</span><span>docker image：列出系统上所有可用的镜像
</span><span>docker pull：从 Docker Hub 或其他注册表拉取映像
</span><span>docker push：将映像推送到 Docker Hub 或其他注册表
</span><span>docker build：从 Dockerfile 构建映像
</span><span>docker exec：在正在运行的容器中运行命令
</span><span>docker logs：显示容器的日志
</span></code></pre>
<p><strong>3. Docker 运行选项</strong></p>
<p>docker run 是 Docker CLI 中最重要的命令之一。您可以使用各种选项自定义容器的行为，例如：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>-d, --detach：在后台运行容器
</span><span>-e, --env：为容器设置环境变量
</span><span>-v, --volume：绑定挂载卷
</span><span>-p, --publish：将容器的端口发布到主机
</span><span>--name：为容器分配名称
</span><span>--restart：指定容器的重启策略
</span><span>--rm：容器退出时自动移除容器
</span></code></pre>
<p><strong>4. Dockerfile</strong></p>
<p>Dockerfile 是一个脚本，其中包含用于构建 Docker 映像的指令。您可以使用 Docker CLI 通过 Dockerfile 构建、更新和管理 Docker 映像。</p>
<p>下面是 Dockerfile 的简单示例：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span># Set the base image to use
</span><span>FROM alpine:3.7
</span><span>
</span><span># Update the system and install packages
</span><span>RUN apk update &amp;&amp; apk add curl
</span><span>
</span><span># Set the working directory
</span><span>WORKDIR /app
</span><span>
</span><span># Copy the application file
</span><span>COPY app.sh .
</span><span>
</span><span># Set the entry point
</span><span>ENTRYPOINT [&quot;./app.sh&quot;]
</span></code></pre>
<p>若要生成映像，请使用以下命令：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>docker build -t my-image .
</span></code></pre>
<p><strong>5. Docker Compose</strong></p>
<p>Docker Compose 是一个 CLI 工具，用于使用 YAML 文件定义和管理多容器 Docker 应用程序。它与 Docker CLI 协同工作，提供一种一致的方式来管理多个容器及其依赖项。</p>
<p>使用官方安装指南安装 Docker Compose，然后您可以创建一个 docker-compose.yml 文件来定义和运行多容器应用程序：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>version: &#39;3&#39;
</span><span>services:
</span><span>  web:
</span><span>    image: webapp-image
</span><span>    ports:
</span><span>      - &quot;80:80&quot;
</span><span>  database:
</span><span>    image: mysql
</span><span>    environment:
</span><span>      - MYSQL_ROOT_PASSWORD=my-secret-pw
</span></code></pre>
<p>使用以下命令运行应用程序：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>docker-compose up
</span></code></pre>
<h2 id="docker-images-docker-jing-xiang"><strong>Docker Images Docker 镜像</strong></h2>
<p>Docker 映像是轻量级、独立且可执行的包，其中包含运行应用程序所需的一切。这些映像包含所有必要的依赖项、库、运行时、系统工具和代码，使应用程序能够在不同的环境中一致地运行。</p>
<p>Docker 映像是使用 Dockerfile 构建和管理的。Dockerfile 是一个脚本，其中包含用于创建 Docker 映像的指令，提供设置应用程序环境的分步指南。</p>
<p><strong>使用 Docker 映像</strong></p>
<p>Docker CLI 提供了多个命令来管理和处理 Docker 映像。一些基本命令包括：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>docker image ls: List all available images on your local system.
</span><span>docker image ls：列出本地系统上所有可用的镜像。
</span><span>docker build: Build an image from a Dockerfile.
</span><span>docker build：从 Dockerfile 构建映像。
</span><span>docker image rm: Remove one or more images.
</span><span>docker image rm：删除一个或多个镜像。
</span><span>docker pull: Pull an image from a registry (e.g., Docker Hub) to your local system.
</span><span>docker pull：将映像从注册表（例如 Docker Hub）拉取到本地系统。
</span><span>docker push: Push an image to a repository.
</span><span>docker push：将镜像推送到存储库。
</span></code></pre>
<p>例如，要从 Docker Hub 拉取官方 Ubuntu 映像，可以运行以下命令：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>docker pull ubuntu:latest
</span></code></pre>
<p>拉取映像后，可以使用该映像和 docker run 命令创建并运行容器：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>docker run -it ubuntu:latest /bin/bash
</span></code></pre>
<p>此命令创建一个新容器，并使用 /bin/bash shell 在容器内启动交互式会话。</p>
<p><strong>Sharing Images 共享镜像</strong></p>
<p>可以使用容器注册表（如 Docker Hub、Google Container Registry 或 Amazon Elastic Container Registry （ECR））共享和分发 Docker 映像。将映像推送到注册表后，其他人可以轻松访问和使用它们。</p>
<p>要共享您的镜像，您首先需要使用正确的命名格式对其进行标记：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>docker tag &lt;image-id&gt; &lt;username&gt;/&lt;repository&gt;:&lt;tag&gt;
</span></code></pre>
<p>然后，您可以使用以下命令将标记的映像推送到注册表：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>docker push &lt;username&gt;/&lt;repository&gt;:&lt;tag&gt;
</span></code></pre>
<p><strong>Containers 容器</strong></p>
<p>容器可以被认为是轻量级、独立和可执行的软件包，其中包括运行软件所需的一切，包括代码、运行时、库、环境变量和配置文件。容器将软件与其周围环境隔离开来，确保它在不同的环境中统一工作。</p>
<p><strong>为什么要使用容器？</strong></p>
<ul>
<li>可移植性：容器确保应用程序在不同平台上一致地工作，无论是开发人员的笔记本电脑还是生产服务器。这消除了“它在我的机器上工作”的问题。</li>
<li>效率：容器是轻量级的，因为它们使用共享资源，而没有成熟操作系统的开销。这样可以缩短启动时间并减少资源使用。</li>
<li>可扩展性：容器可以根据工作负载轻松扩展或缩减，使其成为分布式应用程序和微服务的理想选择。</li>
<li>一致性：容器使开发人员、QA 和运营团队能够在整个应用程序生命周期中拥有一致的环境，从而实现更快、更顺畅的部署管道。</li>
<li>安全性：容器提供与其他容器和底层主机系统的隔离级别，这有助于维护应用程序安全性。</li>
</ul>
<p><strong>使用 Docker CLI 处理容器</strong>
Docker CLI 提供了多个命令来帮助你创建、管理容器并与之交互。一些常用命令包括：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>docker run：用于创建和启动新容器。
</span><span>docker container ls：列出正在运行的容器。
</span><span>docker container stop：停止正在运行的容器。
</span><span>docker container rm：删除已停止的容器。
</span><span>docker exec：在正在运行的容器内执行命令。
</span><span>docker logs：获取容器的日志，可用于调试问题。
</span></code></pre>
<h2 id="docker-volumes"><strong>Docker Volumes</strong></h2>
<p>Docker 卷是一种用于保存 Docker 容器生成和使用的数据的机制。它们允许您将数据与容器本身分开，从而轻松备份、迁移和管理持久性数据。</p>
<p><strong>为什么卷很重要</strong></p>
<p>Docker 容器本质上是短暂的，这意味着它们可以很容易地停止、删除或替换。虽然这对于应用程序开发和部署非常有用，但在处理持久性数据时会带来挑战。这就是销量的来源。它们提供了一种独立于容器生命周期存储和管理数据的方法。</p>
<p><strong>Types of Volumes 卷的类型</strong></p>
<p>Docker 中有三种类型的卷：</p>
<ul>
<li>主机卷 Host Volumes：它们存储在主机的文件系统中，通常位于 /var/lib/docker/volumes 目录中。这些可以很容易地访问，但可能会带来可移植性或文件系统兼容性的问题。</li>
<li>匿名卷 Anonymous Volumes：这些卷是在运行容器时自动创建的，无需指定卷。它们的 ID 由 Docker 生成，也存储在主机的文件系统中。</li>
<li>命名卷 Named Volumes：与匿名卷类似，命名卷存储在主机的文件系统中。但是，您可以提供自定义名称，以便于在其他容器或备份中引用。</li>
</ul>
<p><strong>使用 Docker CLI 进行卷管理</strong></p>
<p>Docker CLI 提供了各种命令来管理卷：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>docker volume create：创建具有给定名称的新卷。
</span><span>docker volume ls：列出系统上的所有卷。
</span><span>docker volume inspect：提供有关特定卷的详细信息。
</span><span>docker volume rm：删除卷。
</span><span>docker volume prune：删除所有未使用的卷。
</span></code></pre>
<p>若要在容器中使用卷，可以在 docker run 命令中使用 -v 或 --volume 标志。例如：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>docker run -d --name my-container -v my-named-volume:/var/lib/data my-image
</span></code></pre>
<p>此命令使用“my-image”映像创建名为“my-container”的新容器，并将“my-named-volume”卷挂载到容器内的 /var/lib/data 路径处。</p>
<h2 id="docker-networks-docker-wang-luo"><strong>Docker Networks Docker 网络</strong></h2>
<p>Docker 网络提供了管理容器通信的基本方法。它允许容器使用各种网络驱动程序相互通信以及与主机通信。通过了解和利用不同类型的网络驱动程序，可以设计容器网络以适应特定方案或应用程序要求。</p>
<p><strong>Network Drivers 网络驱动程序</strong></p>
<p>Docker 中提供了多个网络驱动程序。在这里，我们将介绍四种最常见的：</p>
<ul>
<li>bridge：容器的默认网络驱动程序。它创建一个专用网络，容器可以在其中相互通信并与主机通信。此网络上的容器可以通过主机的网络访问外部资源。</li>
<li>host：此驱动程序删除网络隔离，并允许容器共享主机的网络。它适用于网络性能至关重要的情况，因为它可以最大程度地减少容器网络的开销。</li>
<li>none：此网络驱动程序禁用容器网络。使用此驱动程序的容器在隔离环境中运行，无需任何网络访问。</li>
<li>overlay：此网络驱动程序使部署在不同主机上的容器能够相互通信。它旨在与 Docker Swarm 配合使用，非常适合多主机或基于集群的容器部署。</li>
</ul>
<p><strong>管理 Docker 网络</strong></p>
<p>Docker CLI 提供了各种命令来管理网络。以下是一些有用的命令：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>列出所有网络：docker network ls
</span><span>检查网络：docker network inspect &lt;network_name&gt;
</span><span>创建新网络：docker network create --driver &lt;driver_type&gt; &lt;network_name&gt;
</span><span>将容器连接到网络：docker network connect &lt;network_name&gt; &lt;container_name&gt;
</span><span>断开容器与网络的连接：docker network disconnect &lt;network_name&gt; &lt;container_name&gt;
</span><span>移除网络：docker network rm &lt;network_name&gt;
</span></code></pre>

        </div>

        
        <div class="pagination">
            <div class="pagination__title">
                <span class="pagination__title-h">Thanks for reading! Read other posts?</span>
                <hr />
            </div>
            <div class="pagination__buttons">
                    <span class="button previous">
                        <a href="https://blog.dich.ink/docker-learn-8/">
                            <span class="button__icon">←</span>&nbsp;
                            <span class="button__text">Docker学习笔记(八)</span>
                        </a>
                    </span>
                
                
                    <span class="button next">
                        <a href="https://blog.dich.ink/about-time/">
                            <span class="button__text">乱七八糟:时间的标准与格式</span>&nbsp;
                            <span class="button__icon">→</span>
                        </a>
                    </span>
                </div>
        </div>
    
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2024
 Dichgrem</span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
    </footer>
    

</div>
</body>

</html>